package autoload

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/aras/presto/internal/parser"
	"github.com/aras/presto/internal/resolver"
)

// Generator generates autoload files
type Generator struct {
	vendorDir string
}

// NewGenerator creates a new autoload generator
func NewGenerator() *Generator {
	return &Generator{
		vendorDir: "vendor",
	}
}

// Generate generates autoload.php and related files
func (g *Generator) Generate(composer *parser.ComposerJSON, packages []*resolver.Package) error {
	if err := os.MkdirAll(g.vendorDir, 0755); err != nil {
		return err
	}

	if err := g.generateAutoloadPHP(); err != nil {
		return err
	}

	if err := g.generatePSR4(composer, packages); err != nil {
		return err
	}

	if err := g.generateAutoloadFilesPHP(composer, packages); err != nil {
		return err
	}

	return nil
}

// generateAutoloadFilesPHP generates autoload_files.php for 'files' autoloading
func (g *Generator) generateAutoloadFilesPHP(composer *parser.ComposerJSON, packages []*resolver.Package) error {
	var sb strings.Builder
	sb.WriteString("<?php\n\n// autoload_files.php @generated by Presto\n\n")
	sb.WriteString("$vendorDir = __DIR__;\n")
	sb.WriteString("$baseDir = dirname($vendorDir);\n\n")

	// 1. Root Project Files
	for _, file := range composer.Autoload.Files {
		f := strings.TrimPrefix(file, "/")
		sb.WriteString(fmt.Sprintf("require_once $baseDir . '/%s';\n", f))
	}

	// 2. Package Files
	for _, pkg := range packages {
		if len(pkg.Autoload) == 0 || string(pkg.Autoload) == "null" {
			continue
		}

		var autoloadConfig map[string]interface{}
		if err := json.Unmarshal(pkg.Autoload, &autoloadConfig); err != nil {
			continue
		}

		if files, ok := autoloadConfig["files"].([]interface{}); ok {
			for _, file := range files {
				if f, ok := file.(string); ok {
					f = strings.TrimPrefix(f, "/")
					sb.WriteString(fmt.Sprintf("require_once $vendorDir . '/%s/%s';\n", pkg.Name, f))
				}
			}
		}
	}

	path := filepath.Join(g.vendorDir, "autoload_files.php")
	return os.WriteFile(path, []byte(sb.String()), 0644)
}

// generateAutoloadPHP generates the main autoload.php file, dummy ClassLoader, and InstalledVersions
func (g *Generator) generateAutoloadPHP() error {
	// 1. Create vendor/composer directory
	composerDir := filepath.Join(g.vendorDir, "composer")
	if err := os.MkdirAll(composerDir, 0755); err != nil {
		return err
	}

	// 2. Generate dummy ClassLoader.php
	classLoaderContent := `<?php

namespace Composer\Autoload;

class ClassLoader
{
    private static $loaders = [];

    public function getPrefixes() { return []; }
    public function getPrefixesPsr4() { return []; }
    public function getFallbackDirs() { return []; }
    public function getFallbackDirsPsr4() { return []; }
    public function getClassMap() { return []; }
    public function add() {}
    public function addPsr4() {}
    public function register($prepend = false) {
        self::$loaders[spl_object_hash($this)] = $this;
    }
    public function unregister() {
        unset(self::$loaders[spl_object_hash($this)]);
    }
    public function loadClass($class) {}
    public function findFile($class) { return false; }
    
    public static function getRegisteredLoaders() {
        return self::$loaders;
    }
}`
	if err := os.WriteFile(filepath.Join(composerDir, "ClassLoader.php"), []byte(classLoaderContent), 0644); err != nil {
		return err
	}

	// 3. Generate dummy InstalledVersions.php
	installedVersionsContent := `<?php

namespace Composer;

use Composer\Semver\VersionParser;

class InstalledVersions
{
    private static $installed; 

    public static function getInstalledPackages() { return []; }

    public static function isInstalled($packageName, $includeDevRequirements = true) {
        return true; 
    }

    public static function satisfies(VersionParser $parser, $packageName, $constraint) {
        return true; 
    }

    public static function getVersion($packageName) {
        return '1.0.0'; 
    }

    public static function getPrettyVersion($packageName) {
        return '1.0.0';
    }

    public static function getReference($packageName) {
        return null;
    }

    public static function getRootPackage() {
        return [
            'name' => 'root',
            'pretty_version' => '1.0.0.0',
            'version' => '1.0.0.0',
            'reference' => null,
            'type' => 'library',
            'install_path' => __DIR__ . '/../../',
            'aliases' => [],
            'dev' => true,
        ];
    }
    
    public static function getRawData() { return []; }
    public static function reload($data) {}
    public static function getAllRawData() { return []; }
}`
	if err := os.WriteFile(filepath.Join(composerDir, "InstalledVersions.php"), []byte(installedVersionsContent), 0644); err != nil {
		return err
	}

	// 4. Generate autoload.php content
	content := `<?php
// autoload.php @generated by Presto

// 1. Load PSR-4 map
$map = require __DIR__ . '/autoload_psr4.php';

// 2. Register Autoloader
spl_autoload_register(function ($class) use ($map) {
    foreach ($map as $prefix => $paths) {
        $len = strlen($prefix);
        if (strncmp($prefix, $class, $len) !== 0) {
            continue;
        }

        $relativeClass = substr($class, $len);
        
        if (!is_array($paths)) {
            $paths = array($paths);
        }

        foreach ($paths as $path) {
            // Ensure trailing slash
            if (substr($path, -1) !== '/') {
                $path .= '/';
            }
            $file = $path . str_replace('\\', '/', $relativeClass) . '.php';
            if (file_exists($file)) {
                require $file;
                return true;
            }
        }
    }
    return false;
});

// 3. Load "files" (functions, helpers)
if (file_exists(__DIR__ . '/autoload_files.php')) {
    require_once __DIR__ . '/autoload_files.php';
}

// 4. Load InstalledVersions
require_once __DIR__ . '/composer/InstalledVersions.php';

// 5. Return dummy ClassLoader
require_once __DIR__ . '/composer/ClassLoader.php';
$loader = new \Composer\Autoload\ClassLoader();
$loader->register();
return $loader;
`
	path := filepath.Join(g.vendorDir, "autoload.php")
	return os.WriteFile(path, []byte(content), 0644)
}

// generatePSR4 generates PSR-4 autoload mappings with merged paths
func (g *Generator) generatePSR4(composer *parser.ComposerJSON, packages []*resolver.Package) error {
	psr4Map := make(map[string][]string)

	// 1. Process Project's own autoload
	for namespace, path := range composer.Autoload.PSR4 {
		namespace = strings.TrimSpace(namespace)
		if !strings.HasSuffix(namespace, "\\") {
			namespace += "\\"
		}
		path = strings.TrimSuffix(path, "/")
		psr4Map[namespace] = append(psr4Map[namespace], fmt.Sprintf("$baseDir . '/%s'", path))
	}

	// 2. Process Packages
	for _, pkg := range packages {
		if len(pkg.Autoload) == 0 || string(pkg.Autoload) == "null" {
			continue
		}

		var autoloadConfig map[string]interface{}
		if err := json.Unmarshal(pkg.Autoload, &autoloadConfig); err != nil {
			continue
		}

		processConfig := func(configKey string) {
			if config, ok := autoloadConfig[configKey].(map[string]interface{}); ok {
				for namespace, path := range config {
					namespace = strings.TrimSpace(namespace)
					if !strings.HasSuffix(namespace, "\\") {
						namespace += "\\"
					}

					var paths []string
					switch v := path.(type) {
					case string:
						paths = append(paths, v)
					case []interface{}:
						for _, p := range v {
							if str, ok := p.(string); ok {
								paths = append(paths, str)
							}
						}
					}

					for _, p := range paths {
						p = strings.TrimPrefix(p, "/")
						if p != "" {
							p = "/" + p
						}

						fullPath := fmt.Sprintf("$vendorDir . '/%s%s'", pkg.Name, p)

						exists := false
						for _, existing := range psr4Map[namespace] {
							if existing == fullPath {
								exists = true
								break
							}
						}
						if !exists {
							psr4Map[namespace] = append(psr4Map[namespace], fullPath)
						}
					}
				}
			}
		}

		processConfig("psr-4")
		processConfig("psr-0")
	}

	var mappings strings.Builder
	mappings.WriteString("<?php\n\n// autoload_psr4.php @generated by Presto\n\n")
	mappings.WriteString("$vendorDir = __DIR__;\n")
	mappings.WriteString("$baseDir = dirname($vendorDir);\n\n")
	mappings.WriteString("return array(\n")

	for ns, paths := range psr4Map {
		escapedNs := strings.ReplaceAll(ns, "\\", "\\\\")
		mappings.WriteString(fmt.Sprintf("    '%s' => array(%s),\n", escapedNs, strings.Join(paths, ", ")))
	}

	mappings.WriteString(");\n")

	path := filepath.Join(g.vendorDir, "autoload_psr4.php")
	return os.WriteFile(path, []byte(mappings.String()), 0644)
}
