package autoload

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/aras/presto/internal/parser"
	"github.com/aras/presto/internal/resolver"
)

// Generator generates autoload files
type Generator struct {
	vendorDir string
}

// NewGenerator creates a new autoload generator
func NewGenerator() *Generator {
	return &Generator{
		vendorDir: "vendor",
	}
}

// Generate generates autoload.php and related files
func (g *Generator) Generate(composer *parser.ComposerJSON, packages []*resolver.Package) error {
	if err := os.MkdirAll(g.vendorDir, 0755); err != nil {
		return err
	}

	if err := g.generateAutoloadPHP(); err != nil {
		return err
	}

	if err := g.generatePSR4(composer, packages); err != nil {
		return err
	}

	if err := g.generateAutoloadFilesPHP(packages); err != nil {
		return err
	}

	return nil
}

// generateAutoloadFilesPHP generates autoload_files.php for 'files' autoloading
func (g *Generator) generateAutoloadFilesPHP(packages []*resolver.Package) error {
	var sb strings.Builder
	sb.WriteString("<?php\n\n// autoload_files.php @generated by Presto\n\n")
	sb.WriteString("$vendorDir = __DIR__;\n\n")

	for _, pkg := range packages {
		if len(pkg.Autoload) == 0 || string(pkg.Autoload) == "null" {
			continue
		}

		var autoloadConfig map[string]interface{}
		if err := json.Unmarshal(pkg.Autoload, &autoloadConfig); err != nil {
			continue
		}

		if files, ok := autoloadConfig["files"].([]interface{}); ok {
			for _, file := range files {
				if f, ok := file.(string); ok {
					f = strings.TrimPrefix(f, "/")
					sb.WriteString(fmt.Sprintf("require_once $vendorDir . '/%s/%s';\n", pkg.Name, f))
				}
			}
		}
	}

	path := filepath.Join(g.vendorDir, "autoload_files.php")
	return os.WriteFile(path, []byte(sb.String()), 0644)
}

// generateAutoloadPHP generates the main autoload.php file
func (g *Generator) generateAutoloadPHP() error {
	content := `<?php
// autoload.php @generated by Presto

// 1. Load "files" (functions, helpers)
if (file_exists(__DIR__ . '/autoload_files.php')) {
    require_once __DIR__ . '/autoload_files.php';
}

// 2. Load PSR-4 map
$map = require __DIR__ . '/autoload_psr4.php';

// 3. Register Autoloader
spl_autoload_register(function ($class) use ($map) {
    foreach ($map as $prefix => $paths) {
        $len = strlen($prefix);
        if (strncmp($prefix, $class, $len) !== 0) {
            continue;
        }

        $relativeClass = substr($class, $len);
        
        if (!is_array($paths)) {
            $paths = array($paths);
        }

        foreach ($paths as $path) {
            $file = $path . str_replace('\\', '/', $relativeClass) . '.php';
            if (file_exists($file)) {
                require $file;
                return true;
            }
        }
    }
    return false;
});
`
	path := filepath.Join(g.vendorDir, "autoload.php")
	return os.WriteFile(path, []byte(content), 0644)
}

// generatePSR4 generates PSR-4 autoload mappings with merged paths
func (g *Generator) generatePSR4(composer *parser.ComposerJSON, packages []*resolver.Package) error {
	psr4Map := make(map[string][]string)

	// 1. Process Project's own autoload
	for namespace, path := range composer.Autoload.PSR4 {
		namespace = strings.TrimSpace(namespace)
		if !strings.HasSuffix(namespace, "\\") {
			namespace += "\\"
		}
		path = strings.TrimSuffix(path, "/")
		psr4Map[namespace] = append(psr4Map[namespace], fmt.Sprintf("$baseDir . '/%s'", path))
	}

	// 2. Process Packages
	for _, pkg := range packages {
		if len(pkg.Autoload) == 0 || string(pkg.Autoload) == "null" {
			continue
		}

		var autoloadConfig map[string]interface{}
		if err := json.Unmarshal(pkg.Autoload, &autoloadConfig); err != nil {
			continue
		}

		processConfig := func(configKey string) {
			if config, ok := autoloadConfig[configKey].(map[string]interface{}); ok {
				for namespace, path := range config {
					namespace = strings.TrimSpace(namespace)
					if !strings.HasSuffix(namespace, "\\") {
						namespace += "\\"
					}

					var paths []string
					switch v := path.(type) {
					case string:
						paths = append(paths, v)
					case []interface{}:
						for _, p := range v {
							if str, ok := p.(string); ok {
								paths = append(paths, str)
							}
						}
					}

					for _, p := range paths {
						p = strings.TrimPrefix(p, "/")
						if p != "" {
							p = "/" + p
						}

						fullPath := fmt.Sprintf("$vendorDir . '/%s%s'", pkg.Name, p)

						exists := false
						for _, existing := range psr4Map[namespace] {
							if existing == fullPath {
								exists = true
								break
							}
						}
						if !exists {
							psr4Map[namespace] = append(psr4Map[namespace], fullPath)
						}
					}
				}
			}
		}

		processConfig("psr-4")
		processConfig("psr-0")
	}

	var mappings strings.Builder
	mappings.WriteString("<?php\n\n// autoload_psr4.php @generated by Presto\n\n")
	mappings.WriteString("$vendorDir = __DIR__;\n")
	mappings.WriteString("$baseDir = dirname($vendorDir);\n\n")
	mappings.WriteString("return array(\n")

	for ns, paths := range psr4Map {
		escapedNs := strings.ReplaceAll(ns, "\\", "\\\\")
		mappings.WriteString(fmt.Sprintf("    '%s' => array(%s),\n", escapedNs, strings.Join(paths, ", ")))
	}

	mappings.WriteString(");\n")

	path := filepath.Join(g.vendorDir, "autoload_psr4.php")
	return os.WriteFile(path, []byte(mappings.String()), 0644)
}
