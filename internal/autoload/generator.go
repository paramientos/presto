package autoload

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/aras/presto/internal/parser"
	"github.com/aras/presto/internal/resolver"
)

// Generator generates autoload files
type Generator struct {
	vendorDir string
}

// NewGenerator creates a new autoload generator
func NewGenerator() *Generator {
	return &Generator{
		vendorDir: "vendor",
	}
}

// Generate generates autoload.php and related files
func (g *Generator) Generate(composer *parser.ComposerJSON, packages []*resolver.Package) error {
	if err := os.MkdirAll(g.vendorDir, 0755); err != nil {
		return err
	}

	if err := g.generateAutoloadPHP(); err != nil {
		return err
	}

	if err := g.generatePSR4(composer, packages); err != nil {
		return err
	}

	if err := g.generateAutoloadFilesPHP(packages); err != nil {
		return err
	}

	return nil
}

// generateAutoloadFilesPHP generates autoload_files.php for 'files' autoloading
func (g *Generator) generateAutoloadFilesPHP(packages []*resolver.Package) error {
	var sb strings.Builder
	sb.WriteString("<?php\n\n// autoload_files.php @generated by Presto\n\n")
	sb.WriteString("$vendorDir = dirname(__DIR__);\n\n")

	for _, pkg := range packages {
		if len(pkg.Autoload) == 0 || string(pkg.Autoload) == "null" {
			continue
		}

		var autoloadConfig map[string]interface{}
		if err := json.Unmarshal(pkg.Autoload, &autoloadConfig); err != nil {
			continue
		}

		if files, ok := autoloadConfig["files"].([]interface{}); ok {
			for _, file := range files {
				if f, ok := file.(string); ok {
					f = strings.TrimPrefix(f, "/")
					// Create unique identifier for file to prevent multiple requires?
					// Simple require_once is safer for now
					sb.WriteString(fmt.Sprintf("require_once $vendorDir . '/%s/%s';\n", pkg.Name, f))
				}
			}
		}
	}

	path := filepath.Join(g.vendorDir, "autoload_files.php")
	return os.WriteFile(path, []byte(sb.String()), 0644)
}

// generateAutoloadPHP generates the main autoload.php file
func (g *Generator) generateAutoloadPHP() error {
	content := `<?php
// autoload.php @generated by Presto
require_once __DIR__ . '/autoload_psr4.php';
if (file_exists(__DIR__ . '/autoload_files.php')) {
    require_once __DIR__ . '/autoload_files.php';
}
`
	path := filepath.Join(g.vendorDir, "autoload.php")
	return os.WriteFile(path, []byte(content), 0644)
}

// generatePSR4 generates PSR-4 autoload mappings
func (g *Generator) generatePSR4(composer *parser.ComposerJSON, packages []*resolver.Package) error {
	var mappings strings.Builder
	mappings.WriteString("<?php\n\n// autoload_psr4.php @generated by Presto\n\n")
	mappings.WriteString("$vendorDir = dirname(__DIR__);\n")
	mappings.WriteString("$baseDir = dirname($vendorDir);\n\n")
	mappings.WriteString("return array(\n")

	// Project's own autoload
	for namespace, path := range composer.Autoload.PSR4 {
		escapedNs := strings.ReplaceAll(namespace, "\\", "\\\\")
		// Assume path is relative to project root (baseDir)
		// Handle array of paths if necessary (simplify to single string for now or first element)
		mappings.WriteString(fmt.Sprintf("    '%s' => array($baseDir . '/%s'),\n", escapedNs, path))
	}

	// Packages autoload
	for _, pkg := range packages {
		if len(pkg.Autoload) == 0 || string(pkg.Autoload) == "null" {
			continue
		}

		// Unmarshal autoload config
		var autoloadConfig map[string]interface{}
		if err := json.Unmarshal(pkg.Autoload, &autoloadConfig); err != nil {
			fmt.Printf("Warning: Failed to parse autoload for %s: %v\n", pkg.Name, err)
			continue
		}

		// Check PSR-4
		if psr4, ok := autoloadConfig["psr-4"].(map[string]interface{}); ok {
			for namespace, path := range psr4 {
				// Escape namespace
				escapedNs := strings.ReplaceAll(namespace, "\\", "\\\\")

				// Handle path (can be string or array)
				var paths []string
				switch v := path.(type) {
				case string:
					paths = append(paths, v)
				case []interface{}:
					for _, p := range v {
						if str, ok := p.(string); ok {
							paths = append(paths, str)
						}
					}
				}

				// Generate PHP code
				pathList := make([]string, len(paths))
				for i, p := range paths {
					// Clean path
					p = strings.TrimPrefix(p, "/")
					if p != "" {
						p = "/" + p
					}
					pathList[i] = fmt.Sprintf("$vendorDir . '/%s%s'", pkg.Name, p)
				}

				mappings.WriteString(fmt.Sprintf("    '%s' => array(%s),\n", escapedNs, strings.Join(pathList, ", ")))
			}
		}

		// Check PSR-0
		if psr0, ok := autoloadConfig["psr-0"].(map[string]interface{}); ok {
			for namespace, path := range psr0 {
				escapedNs := strings.ReplaceAll(namespace, "\\", "\\\\")

				var paths []string
				switch v := path.(type) {
				case string:
					paths = append(paths, v)
				case []interface{}:
					for _, p := range v {
						if str, ok := p.(string); ok {
							paths = append(paths, str)
						}
					}
				}

				pathList := make([]string, len(paths))
				for i, p := range paths {
					p = strings.TrimPrefix(p, "/")
					if p != "" {
						p = "/" + p
					}
					pathList[i] = fmt.Sprintf("$vendorDir . '/%s%s'", pkg.Name, p)
				}

				mappings.WriteString(fmt.Sprintf("    '%s' => array(%s),\n", escapedNs, strings.Join(pathList, ", ")))
			}
		}
	}

	mappings.WriteString(");\n")

	path := filepath.Join(g.vendorDir, "autoload_psr4.php")
	return os.WriteFile(path, []byte(mappings.String()), 0644)
}

// Helper to collect files would be better. Let's modify Generate to collect files first.
