package lockfile

import (
	"crypto/md5"
	"encoding/json"
	"fmt"
	"time"

	"github.com/aras/presto/internal/parser"
	"github.com/aras/presto/internal/resolver"
)

// Generator generates composer.lock files
type Generator struct{}

// NewGenerator creates a new lock file generator
func NewGenerator() *Generator {
	return &Generator{}
}

// Generate creates a composer.lock file from resolved packages
func (g *Generator) Generate(composer *parser.ComposerJSON, packages []*resolver.Package) error {
	lock := &parser.ComposerLock{
		Readme: []string{
			"This file locks the dependencies of your project to a known state",
			"Read more about it at https://getcomposer.org/doc/01-basic-usage.md#installing-dependencies",
			"This file is @generated by Presto",
		},
		ContentHash:  g.generateContentHash(composer),
		Packages:     g.convertToLockedPackages(packages, false),
		PackagesDev:  g.convertToLockedPackages(packages, true),
		Aliases:      []interface{}{},
		PreferStable: true,
	}

	// Add platform requirements
	if composer.Require != nil {
		lock.Platform = make(map[string]string)
		for name, version := range composer.Require {
			if name == "php" || name[:4] == "ext-" || name[:4] == "lib-" {
				lock.Platform[name] = version
			}
		}
	}

	return parser.WriteComposerLock("composer.lock", lock)
}

// generateContentHash generates MD5 hash of composer.json content
func (g *Generator) generateContentHash(composer *parser.ComposerJSON) string {
	// Simplified hash - in production, should hash normalized composer.json
	data, _ := json.Marshal(composer)
	hash := md5.Sum(data)
	return fmt.Sprintf("%x", hash)
}

// convertToLockedPackages converts resolver packages to locked packages
func (g *Generator) convertToLockedPackages(packages []*resolver.Package, devOnly bool) []parser.LockedPackage {
	var locked []parser.LockedPackage

	for _, pkg := range packages {
		// TODO: Determine if package is dev dependency
		// For now, add all to production
		if devOnly {
			continue
		}

		lockedPkg := parser.LockedPackage{
			Name:    pkg.Name,
			Version: pkg.Version,
			Dist: parser.DistInfo{
				Type: "zip",
				URL:  pkg.URL,
			},
			Require: pkg.Require,
			Type:    "library",
			Time:    time.Now().Format(time.RFC3339),
		}

		locked = append(locked, lockedPkg)
	}

	return locked
}
